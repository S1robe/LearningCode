#!/usr/bin/python

# Name: Garrett Prentice
# Date: 11/4/23

import networkx as nx
import os

PROMPT = """
Assignment 5 - Main Menu (Enter a number)
1. Add Router to Network
2. Add Cost Connection
3. Run Link-State Algorithm
4. Run Distance Vector Algorithm
5. Exit
"""

# This is used for determining if a router has been changed or not
# Look up by router name
dirty = {}


# Adds a router to the current network
def add_router(graph, router_name: str) -> bool:
    # Router cannot already exist
    if router_name in graph.nodes:
        return False
    else:
        # router has been added to the list, so it starts dirty (no route table)
        dirty[router_name] = True
        graph.add_node(router_name)
        return True


# Adds a connection between two routers at some specified cost
def add_connection(graph: nx.Graph, router1: str, router2: str, cost: int) -> bool:
    # Routers both must exist, otherwise we must add them.
    if router1 not in graph.nodes or router2 not in graph.nodes:
        return False

    # Both routers have changed, both are dirty.
    dirty[router1] = True
    dirty[router2] = True
    # Using 'weight' ensures the build-in algorithms work
    graph.add_edge(router1, router2, weight=cost)
    return True


# Runs the link-state algorithm on the graph, caching results to the router
def ls_algorithm(graph: nx.Graph, source_router: str) -> (dict, dict):
    # Run Dijkstras on the graph from src
    costs, paths = nx.single_source_dijkstra(graph, source_router)
    # Attribute the node with its routing table
    graph.nodes[source_router]['routes'] = {"costs": costs, "paths": paths}
    # Node has been "saved", so it is clean
    dirty[source_router] = False
    return costs, paths


# Runs the distance-vector algorithm on the graph, caching results to the router
def dv_algorithm(graph: nx.Graph, source_router: str) -> (dict, dict):
    # Run the bellman_ford algortihm from src to everywhere.
    costs, paths = nx.single_source_bellman_ford(graph, source_router)
    # attribute the node with its routing table as generated by bellman_ford
    graph.nodes[source_router]['routes'] = {"costs": costs, "paths": paths}
    # Node has been "saved", so its not dirty.
    dirty[source_router] = False
    return costs, paths


# Requests the router name from the user, displays error messages if the router already exits in the network
def getRouterName(graph: nx.Graph = None) -> str:
    # The graph is none when you want to add nodes
    if graph is not None:
        while True:
            name = str(input(f"Select a router: {graph.nodes}\nPress enter without anything to go back.\n"))
            if len(name) == 0:
                sendAndClear()
                break

            elif name not in graph.nodes:
                sendAndClear(f"{name} is not an existing router.")
                continue

            break
        return name
    else:
        while True:
            name = str(input("Please enter a name for the router (Max 16 characters)\nPress enter without anything to go back.\n"))
            if len(name) == 0:
                sendAndClear()
                break

            if len(name) <= 16:
                break

            sendAndClear(f"Name {name} is too long.")

        return name

# Requests the cost between two different routers
def getRouterCost(name1: str, name2: str) -> int:
    while True:
        try:
            cost = int(input(f"Please enter the cost between {name1} <-> {name2}\n"))

            if cost < 0:
                sendAndClear("Costs cannot be negative.")
                continue

            return cost

        except ValueError:
            sendAndClear("Costs must be integers")


# utility method that clears the screen and waits for input after displaying a message
def sendAndClear(message: str = ""):
    if len(message) != 0:
        print(message, "\n")
        input("press enter to continue...\n")

    if os.name == "Windows":
        os.system('cls')
    else:
        os.system('clear')


def clear():
    if os.name == "Windows":
        os.system('cls')
    else:
        os.system('clear')


def printConfiguration(graph: nx.Graph):
    clear()
    print("Nodes:")
    for node in graph.nodes:
        print(node)

    print("Edges:")
    for start,end in graph.edges:
        print(f"{start} -> {end} weight: {graph.edges[start, end]['weight']}")


# Verify that every node can be reached.
def validateConfiguration(graph: nx.Graph) -> (bool, list):
    # Because this is bidirectional graph
    # if I can reach all nodes from one, then all are connected
    # But if there is less (there cannot be more) nodes in a BFS search
    # then I have unreachable nodes and the configuration is not complete

    src = list(graph.nodes)[0] # The first node in the graph
    edges = nx.bfs_edges(graph, src)
    nodes = [src] + [v for u, v in edges]
    missing = set(graph.nodes).difference(set(nodes))
    return len(missing) == 0, missing


# Prints the routing table from start to the rest of the network
def printRoute(start: str, graph: nx.Graph):
    routes = graph.nodes[start]['routes'] # Routes stored after algorithm is ran
    costs = routes["costs"]
    paths = routes["paths"]

    nodes = list(graph.nodes)
    nodes.remove(start)
    # Print the routing table
    for end in nodes:
        print(f"{start} -> {end}: Cost {costs[end]} (Path: {paths[end]})")
    input("press enter to continue...\n")


def main():
    graf = nx.Graph()
    # Infinite Loop, based on user input
    while True:
        try:
            cho = input(PROMPT)
            choice = int(cho)
        except ValueError:
            sendAndClear(f"Not a valid input {cho}")
            continue

        # Switching based on users choice [1 - 5]
        match choice:
            case 1:
                clear()
                while True:
                    # Get the routers name from the user
                    name = getRouterName()
                    if len(name) == 0:
                        break

                    if not add_router(graf, name): # Attempt to add it
                        sendAndClear(f"{name} already exists, please specify another name")
                    printConfiguration(graf)
            case 2:
                clear()
                if len(graf.nodes) < 2:
                    sendAndClear(f"Cannot add a cost to less than 2 routers:\n{graf.nodes}")
                else:
                    while True:
                        print("2 routers are needed.")
                        # Get the router name from the user
                        name1 = getRouterName(graf)
                        # Name is empty indicates misinput
                        if len(name1) == 0:
                            break

                        name2 = getRouterName(graf)
                        if len(name2) == 0:
                            break

                        if name1 == name2:
                            sendAndClear("Cannot add a cost from a router to itself")
                            continue

                        cost = getRouterCost(name1, name2)
                        if not add_connection(graf, name1, name2, cost): # Attempt to add connection
                            choice = str(input(f"Either {name1} or {name2} are not on the network.\nWould you like to add them? (Y/n)"))
                            # QOL ask to add the routers to the network
                            # This will not add duplicates.
                            match choice.lower():
                                case "n":
                                    pass
                                case "no":
                                    sendAndClear("Routers not added")
                                    break
                                case _:
                                    add_router(graf, name1)
                                    add_router(graf, name2)
                                    add_connection(graf, name1, name2, cost)
                                    sendAndClear(f"Routers {name1}, {name2} added to network")
                        printConfiguration(graf)
            case 3:
                clear()
                if len(graf.nodes) < 2:
                    sendAndClear(f"Cannot operate with less 2 routers:\n{graf.nodes}") 
                else:

                    valid, missing = validateConfiguration(graf)
                    if not valid:
                        print("The following nodes need connections:")
                        for node in missing:
                            print(node)
                        input("press enter to continue... \n")
                    else:
                        name = getRouterName(graf)
                        # If the algorithm has not been run for this node
                        # And there has been no change to the node, run the algo
                        if dirty[name]:
                            ls_algorithm(graf, name)

                        print(f"LS Algorithm (from source {name})")
                        printRoute(name, graf)

            case 4:
                clear()
                if len(graf.nodes) < 2:
                    sendAndClear(f"Cannot operate with less than 2 routers:\n{graf.nodes}")
                else:
                    valid, missing = validateConfiguration(graf)
                    if not valid:
                        print("The following nodes need connections:")
                        for node in missing:
                            print(node)
                        input("press enter to continue... \n")
                    else:
                        name = getRouterName(graf)
                        # If the algorithm hasnt been run for this node, 
                        # or the node has not been changed, run the algo.
                        if dirty[name]:
                            dv_algorithm(graf, name)
                        
                        print(f"DV Algorithm (from source {name})")
                        printRoute(name, graf)

            case 5:
                clear()
                print("Exiting....")
                exit(0)
            case _:
                sendAndClear(f"Not a valid input {choice}")
        # continue
    #
#


if __name__ == "__main__":
    main()
